{"version":3,"sources":["../../src/bot/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Module dependencies\n */\n\nimport uuid from 'uuid';\nimport map from 'ramda/src/map';\nimport filter from 'ramda/src/filter';\nimport partial from 'ramda/src/partial';\nimport keys from 'ramda/src/keys';\nimport pickBy from 'ramda/src/pickBy';\nimport hg from 'mercury';\nimport dbg from 'debug';\n\nimport { randomIntFromRange, randomRgbColor } from '../util';\n\nconst debug = dbg('amaze:bot');\n\n/**\n *\n */\n\nexport default function Bot(rows, columns, isCellEnabled, spec) {\n  const totalCells = rows * columns;\n  const _move = partial(\n    move, totalCells, columns, isCellEnabled, isValidIndex\n  );\n\n  // TODO: Consider to not store `col` and `row`,\n  // otherwise we need to update them too while \"moving\"\n  return hg.struct({\n    id: hg.value(spec.id),\n    prevIndex: spec.index,\n    index: hg.value(spec.index),\n    nextIndex: spec.index,\n    col: hg.value(spec.col),\n    row: hg.value(spec.row),\n    color: hg.value(spec.color),\n    move: hg.value(_move),\n  });\n\n  function isValidIndex(totalIndexes, prevIndex, index, nextIndex) {\n    debug('isValidIndex() :: --------');\n    debug('isValidIndex() :: totalIndexes:', totalIndexes);\n    debug('isValidIndex() :: prevIndex:', prevIndex);\n    debug('isValidIndex() :: index:', index);\n    debug('isValidIndex() :: nextIndex:', nextIndex);\n    debug('isValidIndex() :: isBoundary(totalCells, columns, index):', isBoundary(totalCells, columns, index));\n    if (nextIndex === prevIndex) {\n      /*if (totalIndexes > 1\n          && !isBoundary(totalCells, columns, index)) { // TODO: Fix this\n        return false;\n      }*/\n\n      if (totalIndexes > 1/*\n          && !isBoundary(totalCells, columns, index)*/) { // TODO: Fix this\n        return false;\n      }\n\n    }\n\n    return true;\n  }\n}\n\n/**\n *\n */\n\n// TODO: Consider to get color from uuid conversion\nBot.createIdentity = function createIdentity() {\n  const id = uuid.v4();\n\n  // TODO: Prevent from creating duplicated colors. Consider also\n  // to not create vary similar colors\n  const color = randomRgbColor({\n    r: [0, 180],\n    g: [0, 120],\n    b: [0, 220],\n  });\n\n  return { id, color };\n}\n\n/**\n *\n */\n\nfunction move(totalCells, columns, isCellEnabled, isValidIndex, prevIndex, index) {\n  const directions = getAvailableDirections(totalCells, columns, index);\n\n  const indexes = getAvailableIndexes(columns, index, directions);\n\n  function filterIndexes(all) {\n    const filterEnabled = filter(isCellEnabled);\n\n    const enabled = filterEnabled(all);\n\n    const filterValid = filter(\n      partial(isValidIndex, enabled.length, prevIndex, index)\n    );\n\n    return filterValid(enabled);\n  }\n\n  const validIndexes = filterIndexes(indexes);\n\n  const nextIndex = pickRandomIndex(validIndexes);\n\n  return nextIndex !== null ? nextIndex : index;\n};\n\n/**\n *\n */\n\nfunction getAvailableDirections(totalCells, columns, index) {\n  const validDirections = pickValidDirections({\n    u: !isTopBoundary(totalCells, columns, index),\n    r: !isRightBoundary(totalCells, columns, index),\n    d: !isBottomBoundary(totalCells, columns, index),\n    l: !isLeftBoundary(totalCells, columns, index),\n  });\n\n  return keys(validDirections);\n}\n\n/**\n *\n */\n\nconst isValidDirection = val => val === true;\nconst pickValidDirections = pickBy(isValidDirection);\n\n/**\n *\n */\n\nfunction getAvailableIndexes(columns, index, directions) {\n  const indexByDirection = partial(getIndexByDirection, columns, index);\n  return map(indexByDirection, directions);\n}\n\n/**\n *\n */\n\nfunction getIndexByDirection(columns, index, direction) {\n  switch (direction) {\n    case 'u': return moveUp(columns, index);\n    case 'r': return moveRight(columns, index);\n    case 'd': return moveDown(columns, index);\n    case 'l': return moveLeft(columns, index);\n    // no default\n  }\n}\n\n/**\n *\n */\n\nfunction pickRandomIndex(indexes) {\n  const totalIndexes = indexes.length;\n  return totalIndexes\n    ? indexes[randomIntFromRange(0, totalIndexes - 1)]\n    : null;\n}\n\n/**\n *\n */\n\nfunction moveUp(columns, index) {\n  return index - columns;\n}\n\n/**\n *\n */\n\nfunction moveRight(columns, index) {\n  return index + 1;\n}\n\n/**\n *\n */\n\nfunction moveDown(columns, index) {\n  return index + columns;\n}\n\n/**\n *\n */\n\nfunction moveLeft(columns, index) {\n  return index - 1;\n}\n\n/**\n *\n */\n\nfunction isBoundary(totalCells, columns, index) {\n  return isTopBoundary(totalCells, columns, index)\n    || isRightBoundary(totalCells, columns, index)\n    || isBottomBoundary(totalCells, columns, index)\n    || isLeftBoundary(totalCells, columns, index);\n}\n\n/**\n *\n */\n\nfunction isTopBoundary(totalCells, columns, index) {\n  return index < columns;\n}\n\n/**\n *\n */\n\nfunction isRightBoundary(totalCells, columns, index) {\n  return index == columns - 1\n    || (index + 1) % columns == 0;\n}\n\n/**\n *\n */\n\nfunction isBottomBoundary(totalCells, columns, index) {\n  return index >= totalCells - columns;\n}\n\n/**\n *\n */\n\nfunction isLeftBoundary(totalCells, columns, index) {\n  return index == 0\n    || index == columns\n    || index % columns == 0;\n}\n"]}